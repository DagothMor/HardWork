# 1. Это не баг.

Отправка уведомления о копировании в логике, находящейся не в том месте, где проверяется, копирование ли это.
```cs
// Create может сработать единожды и тогда когда файл еще не переименовался системой, следующий вызов после этого события openReparsePoint, потому сделал такую заглушку.
            // TODO: на 18.09.2023 плавающий баг остается, возможно проблема в этом месте, закомментировать и протестировать функционал без этой логики.
            if (_lastOperationIsCreateInSameFolderWithEqualsName && notifyMsg.AccessType == eAccessType.OpenReparsePoint)
            {
                _lastOperationIsCreateInSameFolderWithEqualsName = false;
                _filePathFromlastOperationIsCreateInSameFolder = String.Empty;
                AddSendEventMessage(new ClientEventMessage(notifyMsg.FullFilePath, eEventType.CopyDocEvent, _explorerOpenFullFilePath));

            }
```

# 2. Это не баг (а что-то другое)
Когда мы промониторили поведение сигнала и сделали выводы что это одно из тех что мы должны отправить на сервер, мы отправляем объект в очередь отправки на сервер. Именно в обработчике в зависимости от типа события над файлом происходят разные манипуляции с объектом события и/или с файлом(попытка достучаться к еще не созданному файлу, если событие копирования).
# 3. Это сбивает людей с толку
# 3.1
После создания объекта(в конструкторе происходит открытие файла), записи новой метадаты в файл, вызова Dispose(закрывает файл перед освобождением ресурсов.), мы снова создаем объект с этим файлом(открываем, закрываем), только для того чтобы пользователь смог без ошибок открыть его(баг во внешней библиотеке, отвечающей за открытие файла.) 
# 3.2
Такая же логика была при работе указателя системы(openreparsePoint), файл мог быть вообще пустым, тогда создавалась с нуля метадата и после снова переоткрывалась.
# 4. Это хрупкость
## 4.1 Последняя реализация кэша.
Кэш документов в системе представляет собой путь к файлу как ключ, а метадату с меткой как значение, и на текущий момент очищается тогда и только тогда, когда мы явно отправляем файл в корзину. Логика времени жизни на данный момент является рудиментарной. Прекрасно понимаю что может быть сценарий, когда у пользователя по 100 открытых документов и 1к-5к документов с которыми производилась работа. Понятия не имею как себя поведет программа при этом сценарии. Однако для mvp достаточно и в будущем все равно будем переделывать с нуля(я очень надеюсь).

## 4.2 Захват только одного экрана
При открытии документа мы создаем объект который мониторит имя файла в шапке окна Windows, и если оно подходит к открытому документу, у которого стоит запрет копирования в буфер обмена, то мы соответственно очищаем буфер обмена.
Но если мы откроем еще один документ, создастся еще один объект.
Решение очевидно, но на реализацию мьютекса и тестирование времени не выделили, поскольку функционал на текущий момент только для 1 рабочего документа...

# 5. Не соответствует требованиям OSHA (Администрация по охране и гигиене труда США)
Из старых ответов по hardwork:
```cs
using (var _ = new StreamReader(filePath)) { }
```
Новоиспеченному разработчику покажется что это пустой код, но удалив его вся система сломалась бы потому что при открытии через наше приложение, мы не смогли бы зарегистрировать его в глобальном кэше и тогда при каждом сигнале к этому файлу будет произведена попытка открытия.(к счастью это было пофикшено)

___
Большая часть выше перечисленного порождено мной. Большую часть можно было бы исправить/переписать, написать документацию и простроить архитектуру, но когда каждую неделю давят говорят: сроки, сроки, сроки... когда каждый день всей Осени слышишь: Ждем инсталлятор к вечеру, когда все сгорело и когда пепел сгорел оставив после себя пепельный пепел который тоже догорает, ты начинаешь задумываться, а стоило ли вообще торопиться и забивать на оставшиеся после себя баги?  