# 1. 

Рабочая программа на вм падала при запуске из за того что подключил системную библиотеку System.IO.Pipes. После билда руками переносил файлы с измененным кодом, но не учел, что добавив в using новые пространства понадобились новые библиотеки которые были сгенерированы в билде без истории модификации. Из решений: обычная публикация и полное копирование со вставкой с заменой, или же Self-contained публикация. 
```
Visual Studio позволяет сделать Self-contained публикацию, которая будет включать в себя весь NET Core (ну или нужную его часть), при этом размер самого `.exe` файла увеличится до ~150 мегабайт, будет работать без уcтановленного .NET Core. В противном случае, требуется установка .NET Core Runtime.
```
От этих решений сознательно отказался, легче было при тесте на вм кидать пару файлов с правленным кодом, учитывая что могут быть сбилжены нужные библиотеки, поскольку работа с корп вм это время.
# 2. 
Как раз на работе такая ситуация.
Есть бинарные файлы DOC и в них нужно зашить/прочесть метаданные.
Логично что если зашиваем то нужна утилита которая откроет этот бинарник и прочтет то что нам нужно.
Для данного вида работ существуют две библиотеки .Microsoft.Interop прекрасно справляется, однако проблема в том что юристы и аналитики дадут вам по шее, поскольку брать в свой проект нельзя, а продажники будут в  недоумении из за того что наш продукт должен устанавливаться только после установки microsoft office(оттуда же вытаскивается нужная нам библиотека, привет зависимости на уровне установленных приложений).
b2x translator, и его адаптация под наши нужды
https://habr.com/ru/companies/auriga/articles/528084/

У меня была страшная непонятная ошибка возникавшая когда я пытался запустить свою консольку с кодом из тестов 
https://github.com/ipetrovanton/OfficeToXml/tree/DocToXML
Приходилось углубляться в код, смотреть зависимости, и решением было...

Понизить консольку с net5 на netcore 3.1 ...

Эта зависимость была неосознанной, и довольно болезненной и унизительной(смотрю на небо идя по *грязи*)

Однако это другой случай, вернемся к зависимости реализаций А и В, допустим у нас нет библиотек выше, и мы решили написать с нуля А и В для doc.
От чего мы будем отталкиваться? от А для В или от В для А? Куда записывать информацию, в какой сектор итд?
вот от чего
https://www.opennet.ru/docs/formats/wword8.html#21
И это для doc, мы еще не говорили про ppt где большая часть по сути картинки, а у них уже другая архитектура файла.
В общем А и В зависят от архитектуры файла, потому что окружение задает тебе правила и ограничения.


# 3. 
отправка уведомления на сервер требует вытащить метаданные из кэша файлов с которыми работало приложение. Однако если будет много событий файла которые нужно обработать, и если время жизни элемента кэша истекло только к середине обработки всех этих событий, то мы потеряем все оставшиеся события, они не придут на сервер, поскольку метаданные не были найдены.
Решением было добавление проверки, открыт ли файл на данный момент, если нет то можно спокойно удалять информацию о нем из кеша
Сознательно.

# 4. 
Описал во 2 пункте про версии.

# 5. 
При создании файла через приложение 1, приложение 2 ловит сигналы от него, понимает что в кэше его еще не было и пытается достучатся, но он либо еще не существует, либо занят, отчего случались ошибки, для этого была создана переменная хранящая в себе имя файла, менялось значение от приложения 1 через IPC. Приложение 2 после проверки отсутствия файла в кэше перед тем как постучаться к файлу, смотрит на эту переменную, и если имена совпадают то готовит дефолтный ответ на разрешение операции. Данное решение хорошо работает, но можно было и упростить тем чтобы через протокол IPC отправить информацию о файле и о пустой метадате(0000-0000-0000-0000).
Решение было интуитивным

# 6. 
Не сталкивался к сожалению на работе и в проектах с таким видом ошибок.
Решение осознанное, почти все проекты были MVP, а следовательно нагородили интерфейсы и пробрасывали в DI

# 7. 
Помню в Directum Rx был баг когда в карточке документа, во время изменения поля ФИО менялся автоматически пол, но был код что когда меняется пол то мы должны очистить ФИО...
Это было легаси, конечно же от этой фичи избавились.

# 8 
Скорее всего зависят потому что они отталкиваются от метода внешнего объекта(наш equals и базовый который конфликтуют).
В работе подобного к сожалению не встречал.

# 9. 

Пару коллег писали свои реализации кэша отработанных документов, каждая из них сталкивалась с проблемой несвоевременного сгорания элемента.
Решение было неосознанным, каждый пишет, изучает,защищает только свою подсистему.
