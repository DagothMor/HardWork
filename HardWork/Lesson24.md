# 1 Зависимость от библиотеки DocToXML

https://github.com/ipetrovanton/OfficeToXml/tree/DocToXML
что является форком от 
https://github.com/EvolutionJobs/b2xtranslator
## 1.1 Семантика

### 1.1.1 Зависимость сборки
Библиотека заточена только на .NET Core 3, если вызвать ее в приложении что выше платформой(Net core 5 6 7...), то выйдет удивительный баг
https://github.com/EvolutionJobs/b2xtranslator/issues/1

### 1.1.2. Зависимости времени выполнения.
Компилятор преобразует в IL код в виде сборок, затем приложение использует CLR и JIT компилятор для преобразования IL в машинный код, который выполняется процессором. 
### 1.1.3. Функциональные требования.
Динамическая семантика, если попытка преобразования бинарного файла падает с ошибкой, то падает и сама наша программа. Да и вообще вся наша программа завязана именно на этой библиотеке, поскольку альтернатив в рамках юридического права нет( или мало искал альтернатив.) 
## 1.2 ключевые свойства
Главная зависимая характеристика - это конвертирование файла, по сути предназначение самой программы, даже если мы и сделаем отдельный слой, то какой смысл, если других вариантов нет.
## 1.3 пространство допустимых изменений
Пространством на текущий момент является сгенерированная папка с текстом и картинками, находящаяся в расположении исполняемого файла.

## Супер-спецификация
Очень капризная библиотека, зависимость от платформы, от прямого вызова библиотечных классов. Обновление может крашнуть билд проекта из за других неймингов классов. 

# 2 Зависимость от драйвера

## 2.1 Семантика
### 2.1.1 Зависимость сборки
Обязательно должна быть цифровая подпись драйвера

### 2.1.2. Зависимости времени выполнения.
Так же как и в первом примере, драйвер пишется на С, компилируется в машинный код и после выполняется процессором.
### 2.1.3. Функциональные требования.
Динамическая семантика.
Не дай бог будет утечка памяти, Винда крашнется.
Анализ и отправка сигналов файловой системы, если не отправит из 5 сигналов создания хоть 1, то агент пропустит это событие и не отправит его на сервер.
Как говорится
```
«Время и место каждого Подвига определяются Судьбой. Но если не придет Герой, не будет и Подвига» (**Зурин Арктус, подземный король**).
```
## 2.2 ключевые свойства
Как и в 1 примере, приложение агента всего лишь обрабатывает и упорядочивает сигналы от драйвера.
Ключевое свойство это правильная последовательность приходящих сигналов, благодаря которым мы можем отделить мусорные сигналы, от тех которые говорят нам что произошло высокоабстрактное действие.
## 2.3 пространство допустимых изменений
Только получение сообщения и его поля.

## Супер-спецификация
Мне легче отталкиваться задавая себе вопрос, что может порушить бизнес логику моего приложения, если ктото чтото гдето както в драйвере?
Конечно это порядок сообщений от него, а так же изменение нейминга полей сообщения.

# 3 API телеграм бота
## 3.1 Семантика
### 3.1.1 Зависимость сборки
https://github.com/TelegramBots/Telegram.Bot
Указывается самодостаточность + пару расширений
```
- [Telegram.Bot.Extensions.LoginWidget]
- [Telegram.Bot.Extensions.Passport]
```
минимальная платформа 
Project targets **.NET Standard 2.0** and **.NET 6** at minimum.

Ну и никто не отменял старые версии, работающие на более ранних платформах, однако проект в долгосрок проиграет, и рано или поздно придется подниматься.

### 3.1.2. Зависимости времени выполнения.
см пункт 1.1.2.
### 3.1.3. Функциональные требования.
Есть множество иных клиентов для c# работающих с 
https://core.telegram.org/bots/api
Однако подходы бывают совсем разные, гдето достаточно сделать объект класса, а где то с его дополнительными настройками, однако я вижу этот подпункт как:"У нас есть бизнес логика которая может выполнится разными инструментами, давай сделаем подушку безопасности и подготовим почву для переезда с одной технологии на другую"
## 3.2 ключевые свойства
Взаимодействие с пользователем посредством мессенджера Telegram, отправка скачанной музыки в пост группы.
## 3.3 пространство допустимых изменений
Пространством является подключение к боту(через апи ключ), отправка информации(файл и/или текст) в указанную группу.

## Супер-спецификация
Третье измерение напомнило о себе когда я пытался поднять версию телеграм бота, запуск стал другим, классы поменялись, подход поменялся.
# 4 Зависимость от приложений взаимодействующих с файлами
## 4.1 Семантика
### 4.1.1 Зависимость сборки
Приложение А использует Авалонию для UI, конечно желательно последнюю платформу на .NET, Приложение Б использует системные библиотеки Windows, потому оно обязательно должно быть на .Net Framework
Сам агент(главное приложение) на .net standart 2.0 поскольку нужно взаимодействие с приложением выше.
Вот такая солянка...
### 4.1.2. Зависимости времени выполнения.
см пункт 1.1.2.
### 4.1.3. Функциональные требования.
Динамическая семантика.
Если приложение А не передаст информацию о новом гуид для файла в кеш главного приложения, могут отправляться неправильные данные.
Если приложение Б не передаст информацию о готовящемся новом файле, то возникнет конфликт.
## 4.2 ключевые свойства
Есть несколько свойств главного приложения которые меняются благодаря приложениям А и Б, 
Это глобальный кеш отработанных приложений, и специальная переменная, отвечающая за пропуск обработки файла.
## 4.3 пространство допустимых изменений
Для приложения А спецификацией является корректность изменения метаданных файла, и обязанность уведомления главного приложения об измененном файле.
Для приложения Б обязанность уведомлять об открытии/закрытии файла и его создании.

## Супер-спецификация
Возвращаясь к старым реализациям приложения Б можно вспомнить как передавалась информация о файле( не через пайпы, а используя конструктор потока для его псевдооткрытия.) Может все поломаться, если изменить имя проекта, поскольку главное приложение хранит хардкодом, какие приложения игнорировать, что по сути своей конечно же неправильно, однако случай узконаправленный и вообще для этого существует документация.
# Итог
По итогу прочитанного понял что зависимость это не существующий объект, а абстрактное явление, комбинирующее в себе от 1 до ~10 суб контекстов. Да у нас есть DI слой который ограничивает наш код от вызова сторонних библиотек, но это не значит что мы теперь не зависим от нее. Да у нас может быть несколько метрик но у каждой метрики может быть своя супер-спецификация. Допустим у нас есть несколько платежных сервисов как план Б, но с пессимистической точки зрения, когда все стороннее валится, мы в проигрыше. И с этой пессимистической точки зрения мы давно должны были умереть с голоду, поскольку электричество отключили, следовательно жена не смогла приготовить завтрак, пойдя в мак, оплата по карте не прошла, пойдя в ближайшую шаурмечную мы узнаем что она закрыта из за санитарного дня итд...
Не нужно максимализировать зависимость, не надо быть оптимистом, говоря что и 1 бд достаточно(привет mssql), не нужно быть пессимистом тратя время разработки на адаптацию проекта под любую бд. Играет тут золотая середина, пара, тройка альтернатив вполне достаточно, и если все они повалились то чтож, или пора повышать квалификацию, или покупать лотерейный билет.