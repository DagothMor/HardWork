# 9
Походит на случай "фантомных сигналов от драйвера", когда мы получаем сигнал и обрабатываем его, может случится тот случай, когда сигнал пустой(OpenReparsePoint) в рамках действия копирования, отчего рушится вся дальнейшая логика обработки будущих сигналов и в дальнейшем не делается вывод что произошло копирование. Решением было проверка этого сигнала, если он указывает на тот же файл что и предыдущий сигнал типа Create, то мы игнорируем его.

Если подсистема выдала не то значение что и большинство, то нужна дополнительная прослойка которая анализирует ответ, отталкиваясь от решение остальных подсистем, таким образом мы повысим вероятность правильности поведения.

# 8
Как говорил, в работе не встречал, однако можно догадаться, что если хэштаблица не виновна, то вина на входных данных, решением вижу писать простые тесты что переделанный string.equals будет возвращать то же что и базовый, а так же не переписывать для переделанного класса, а использовать расширение, и с ним работать, хотя и тут будет вероятность что разработчики забудут/не знали что нужно использовать EqualsOverrideString вместо Equals.
# 7
Нужно все же понять, транзитивная связь или нет.
Я долго думал над вашими словами касаемо

что это вообще значит для А -- зависеть от А

Я понял филосовски, подобно тому как быть человеком.
Человек зависит от собственных потребностей.
Если какая то сущность существует, то она продолжает существовать только благодаря своим потребностям.
Человек без своих потребностей - труп/овощь
Компьютер без электричества - ящик.
Не будет героя не будет и подвига.

Если транзитивная(зависимость от библиотеки), то решением будет...избавление от библиотеки...
Избавление имеется в виду как я назову скорее "Поглощение"
Изучив библиотеку и написав свою реализацию/сделать форк и внедрить в само приложение.
Пока других идей не возникало.

Если не транзитивная и отталкиваясь от ситуации с смс и звонком, то решением будет снижение ошибок в этой ситуации, а именно написание оболочки, которая подсвечивает номер и достаточно тыкнуть на номер-гиперссылку, и тогда уж точно не промахнешься.

# 6
Я начинал с 9 пункта на снижение, и вот перечитав заново увидел схожесть моей мысли касаемо "Поглощения"
Однако как и в прошлом ответе 22 я не встречал на практике такого, вижу лишь более подробное горождение интерфейсов перед использованием DI
# 5

Первое, составить список комбинаций взаимозаменяемых вариантов(множества), и прописать сценарии невыполнения для каждой комбинации.

Второе, уведомление о переходе на план B C D... можно даже прописать дополнительную логику помимо самого логирования(отправить чек об оплате на рабочую/админскую почту.)
Сама ситуация пункта 5.2 зависит от контекста, если подходы схожи, различий минимум, то можно и проигнорировать.
Однако если у нас вышел ексепшн и мы перенаправляем пдф на онлайн платформу, то нужно оборачивать ее доп логикой, будет грустно когда придет тимлид и даст вам по бошке из за того что aspose сожрал тысячу долларов на обработку огромных пдф файлов про кулинарию.

# 4
В рамках работы отлов любых исключений в тех местах кода, где может выскочить ошибка из суперспецификации.

# 3
Предыдущий ответ без изменений.
отправка уведомления на сервер требует вытащить метаданные из кэша файлов с которыми работало приложение. Однако если будет много событий файла которые нужно обработать, и если время жизни элемента кэша истекло только к середине обработки всех этих событий, то мы потеряем все оставшиеся события, они не придут на сервер, поскольку метаданные не были найдены.
Решением было добавление проверки, открыт ли файл на данный момент, если нет то можно спокойно удалять информацию о нем из кеша
Сознательно.


# 2
Решением будет написание тестов, точная проверка что добавление метаданных и его же удаление даст исходный файл побитово.
И именно возвращение исходного состояния, а не его работоспособность. Ведь может же быть такая ситуация когда во время многократного тестирования(добавление и удаление метаданных) может поломать файл тем что там накопились куча системных символов(пустых).

# 1

Ситуация немного иная в рамках фреймворка. Зависимость платформы(windows,Linux) и зависимость лицензии играют самую главную роль при выборе и использовании.
Решение тут глупое, поиск альтернатив, связь с юристами
___
Зависимость будет везде и всегда, нужно в рамках системного мышления отделить уровни и типы зависимостей, и поработать над ними чтобы точность была максимально высокой и чтобы были альтернативные варианты, приближая возможность поломки нашего продукта к 0. 
Нужно помнить что Лучшее враг хорошего.
Зависимость должна решаться(и это неправильно, правильно снижаться) рационально.