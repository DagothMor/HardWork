# 1 не модифицировать переменную по ссылке, которая будет являться частью ответа.

В c# передача экземпляров класса в качестве параметра идет как ссылочный тип.
Как производилась логика раньше:
Получение сигнала от драйвера -> Конвертация сигнала в экземпляр-> отправка экземпляра сигнала драйвера и созданный заранее результат обработки сообщения от драйвера в метод который по сути своей и обрабатывает драйвер...
```cs 
 /// <summary>
    /// Результат обработки сообщения от драйвера.
    /// </summary>
    internal class ResultProc
    {
		/// ...
        /// <summary>
        /// Тип результата обработки.
        /// </summary>
        public eResProc ActionType { set; get; }
        /// <summary>
        /// Оповещать пользователя.
        /// </summary>
        public bool NotifyUser { get; set; }

        /// <summary>
        /// Отправлять событие на web клиент.
        /// </summary>
        public bool SendToWebClient { get; set; }

        /// <summary>
        /// Добавлять в кеш.
        /// </summary>
        public bool AddToCacheAnswers { get; set; }
        /// ...
        
```
Логика выходит максимально запутанной, особенно когда экземпляр результата проходящий по пайпе, модифицируется в разных местах
```
/// 4. если процесс из списка офисных программ то меняем булеву об уведомлении пользователя, если произошел блок

/// 6. если процесс explorer.exe то меняем булеву об обязательности добавления в кеш ответов для пропуска будущих сигналов.

```
Происходила путаница при отладке и расширении логики обработки сообщения в пайплайне. Решение было радикальным, просто не передавать заранее дефолтный ответ. Жестко привязать генерацию ответа после обработки одного из сценариев.
```cs
// Заблокировать доступ процессу, не порожденному прокси.
            if (!ProcNameCheck.PIDParentIsProxy)
            {
                return new ResultProc()
                {
                    ActionType = eResProc.AppIsNotSupported,
                    ProcessName = processNameChecker.ProcessName,
                    AddToCacheAnswers = true,
                    NotifyUser = true,
                    SendToWebClient = false
                };
            }
```

Да жесткое привязывание вызывает дублирование конструктора ответа(по большей части ответы дефолтные - ничего не делать, никого не уведомлять, ничего не отправлять и ничего не сохранять.) однако это необходимое зло которое не так уж и сильно нагромождает чтение кода, зато избавляет от припоминания того что в таком то сценарии отправляется.
# 2
Так же в легаси был пример когда модифицировался сигнал от драйвера во время его обработки, происходила путаница в частности с событиями удаления и перемещения(что по сути одно и то же). Баги выскакивали такие что в мониторинге событий отправлялись системные пути.
```cs
case eDriverEventType.Move:
                    // Во избежании отправки на сервер события удаления(ибо файл при лайт делите ПЕРЕМЕЩАЕТСЯ в корзину)
                    // C:\$RECYCLE.BIN\{UserSID}\$RIRR4C6.docx.
```

Дизайн метода обработки был изменен, добавлен модификатор in(параметр становится readonly и в будущем разработчики будут расширять логику опираясь на данное условие.) для notificationMessage, так же добавлен параметр переименованного пути файла.
```cs
AddSendEventMessage(new ClientEventMessage(notificationMSG.FILEPATH, eEventType.DocRemoved, notificationMessage.RenamedFullFileName));
```
