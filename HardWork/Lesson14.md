# 1
```
Иногда большие функции предлагают лучшие абстракции, а маленькие функции приводят к запутанным схемам взаимодействия.
```
Как и писал в предыдущих отчетах. Никаких открытий файла в конструкторе и закрытия его в Dispose. Нельзя городить кучу маленьких методов(открыть, закрыть, сохранить, получить метадату документа, проверить и установить глобальную переменную только_для_чтения во время жизни экземпляра класса FileManager прости Господи). Потому что в будущем вы(следующее поколение разработчиков) забудете/перепутаете порядок вызова этих атомарных операций при составлении транзакционных если можно сказать методов(замена метадаты шаблонного документа это -> ПОПЫТКА ОТКРЫТИЯ -> Генерация новой метадаты -> Сохранение документа -> Закрытие), и по итогу у вас документ может заблокироваться на время всей жизни программы(Конструктор придет на помощь конечно же, но когда он вызовется то вообще?)

# 2
Плюсы и Минусы могут быть перемешаны в зависимости от задачи(описаны подробнее в пункте 3)
Плюсы неканонически "ослабленного" TDD прекрасно ложатся для случая 1, однако для случая 2 может происходить так что "Сначала я напишу чтобы просто работало, а потом посмотрю в каких сценариях может упасть, тогда поправлю."
# 3 
Проблема в том что я никогда на серьезном уровне не писал тесты, и потому этот список:
```
- интеграционное тестирование
- сквозное тестирование
- мутационное тестирование
- фаззинг(на детском уровне, статья все еще в процессе написания.)
- тестирование свойств
- тестирование на основе моделей
- ручное тестирование
- инспекции кода
- тайп-чекеры
- статический анализ
- контрактное программирование
- распихивание assert-ов повсюду :) (описывал в 3 отчете.)
```
в понимании дается тяжело, особенно не в тех задачах когда приложение нужно выбирать в зависимости от расширения документа и ограниченных комбинаций. Как тестировать открытие документа через мое приложение отталкиваясь от поведения другого который мониторит сигналы от драйвера Windows? Как тестировать множественное открытие документа по сто раз щелчком левой кнопки мыши? 50 раз открыть 25 закрыть и еще пару открыть и в 17 открытом документе WORD постараться открыть другой файл? Успеет ли добавиться в список открытых документов? Ну хорошо, я избавился от жесткого вызова StreamReader в приложении 1 чтобы драйвер выловил этот момент, передал приложению 2, он же в свою очередь по очередной наложенной костыльной логике добавил в кеш открытых документов. Переписал и отправляю через IPC протокол(и то их уже немало: передача пути файла и его метадаты чтобы приложение 2 не пыталось его невовремя открыть ради метадаты, передача ПИД процесса приложения 1 и пути файла чтобы игнорировать любые вызовы от этого ПИДа, и передача ПИД процесса приложения 1 для того чтобы удалить из кеша открытых документов) однако поведение поменялось, что делать с теми тестами которые были написаны для варианта добавления в кеш открытых документов через streamreader? Закомментировать/Удалить.
Давайте оттолкнемся от двух случаев на моей работе.
# 1 случай
Тот что был в 3 отчете
https://github.com/DagothMor/HardWork/commit/b8dd1cf9ff8d2b79c134a582e9c08deaea6e9bf6
Мы понимаем нашу цель, есть правила, есть список расширений, есть приложения которые открывают файлы со специальными расширениями.
Написать ряд тестов учитывая логический дизайн не составит труда.

# 2 случай
Понять что файл скопировался а не создался, понять что он удалился а не был перемещен из рабочего стола в корзину и т.д.
Понять что редактировалось содержимое, а не его метадата. Разрешить редактировать содержимое, только если открыто доверенное приложение, созданное нами.
Кто знает паттерн поведения Kernel при атомарных операциях над файлом? а над файлами? Множественное копирование, ловится непоследовательными вызовами, это вам не обыкновенное копирование над единичным экземпляром в проводнике, да и то от ядра бывает идет вызов на несуществующий файл, который и не создастся. Кто знал что при создании процесса р7 офис от нашего приложения 1, на самом деле этот процесс удаляется а заместо него создаются аж целых 3 процесса р7, и у всех родитель системный ПИД а не наш...Как решается? да обычной логикой, процесс создали? да. Удалился? да. Подождали секунду две? да. есть новые 3 ПИДа р7? да. Ну вот и доверяй им.
Я увлекся, конечно же понятно что тут 3 стадия управляемого хаоса, которая одним шагом на 4 стадии - неуправляемый хаос.
Как в таком случае писать тесты? Конечно же примитивный уровень никто не отменял из оперы проверки на null, передача некорректных параметров в метод. Да и протестировать методы которые используют IPC (NamedPipeServerStream) проблем не составит труда. Но что выше? Уровень абстрактности частного случая 1 явно пониже чем в текущем.
Ах да и конечно же время поджимает и конечно же прототип где костыль на костыле.
По итогу хочу сказать что я с радостью бы почитал, изучил, научился писать всевозможные тесты для высоких абстракций приближенных к логическому дизайну 2 случая(почти неуправляемый хаос, реализаций может быть много, много внешних сложных внешних факторов).
И конечно же понять - для 1 стадии хаоса управляемой упорядоченности(понятный легкий с минимумом факторов логический дизайн) писать тесты, ассерты не составит труда. 

Но что там выше?

Какие инструменты использовать наверху?